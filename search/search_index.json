{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to the Atomic Cloud project! Please note that the cloud is currently in its early development stages, and you might encounter occasional bugs. If you experience any issues, please report them by opening an issue on our GitHub repository.</p>"},{"location":"#documentation-status","title":"Documentation Status \ud83d\udea7","text":"<p>This documentation is a work in progress. We apologize for any grammatical errors or incomplete sections. We welcome contributions from the commservery\u2014if you\u2019d like to help improve the documentation, please consider submitting a Pull Request.</p>"},{"location":"#features","title":"Features","text":""},{"location":"#command-line-interface-cli-application","title":"Command Line Interface (CLI) Application","text":"<p>The Atomic Cloud platform includes a powerful Command Line Interface (CLI) application that simplifies the management and control of your cloud resources\u2014similar in functionality to <code>kubectl</code>. This tool is designed to streamline your workflow by eliminating the need for frequent SSH logins when making minor adjustments. More details</p>"},{"location":"#robust-apis","title":"Robust APIs","text":"<p>The Atomic Cloud platform features a sophisticated API suite designed to enhance server communication and overall system efficiency. More detail</p>"},{"location":"#modular-backend","title":"Modular Backend","text":"<p>Atomic Cloud is built on a versatile plugin system that abstracts and streamlines the process of initiating servers. This modular approach allows the platform to support various backends, ensuring flexibility and scalability. Take a look</p>"},{"location":"#no-proxy-usage","title":"No Proxy Usage","text":"<p>Atomic Cloud is engineered using the latest Minecraft transfer packet technology, eliminating the need for traditional proxy software such as Velocity or BungeeCord. This innovative approach provides several key advantages:</p>"},{"location":"#reduced-latency","title":"Reduced Latency","text":"<p>By removing the proxy layer, Atomic Cloud minimizes network overhead, significantly reducing latency. This results in a smoother and more responsive gaming experience for players.</p>"},{"location":"#regional-player-distribution","title":"Regional Player Distribution","text":"<p>Without a centralized proxy, players can be seamlessly distributed based on their geographical regions. This not only improves server performance but also enhances the overall player experience by connecting them to the nearest available server.</p>"},{"location":"#enhanced-network-stability","title":"Enhanced Network Stability","text":"<p>Eliminating the proxy creates a more resilient network architecture. Without a single point of failure, the system is better protected against crashes. For instance, if a lobby experiences a failure, a new lobby is automatically initiated on a random port, making it more challenging for attackers to target and disrupt the network consistently.</p> <p>Atomic Cloud's no-proxy design ensures a robust, efficient, and secure environment, providing significant performance improvements and increased reliability for all players.</p>"},{"location":"api/","title":"Available Options","text":"<p>Atomic Cloud provides a first-party JVM library designed to offer seamless integration for developers working within the JVM ecosystem. This library is compatible with all programming languages that compile to JVM bytecode, making it a versatile and powerful solution for a wide range of projects.</p> <p>Key benefits include:</p> <ul> <li> <p>Broad Compatibility:   Leverage the library with any JVM-based language, including Java, Kotlin, Scala, Groovy, and others.</p> </li> <li> <p>First-Party Support:   Enjoy the reliability and robustness of a library developed and maintained by the Atomic Cloud team.</p> </li> <li> <p>Versatile Integration:   Easily integrate cloud functionalities into your existing JVM projects, streamlining development and enhancing application performance.</p> </li> </ul> <p>Explore this option to maximize your development capabilities within the JVM environment.</p>"},{"location":"api/jvm/","title":"JVM API Integration","text":"<p>The Atomic Cloud API is available through the GitHub Packages Maven repository. Authentication may be required to access it. For more details, visit the package page.</p>"},{"location":"api/jvm/#adding-the-api-to-your-project","title":"Adding the API to Your Project","text":""},{"location":"api/jvm/#maven","title":"Maven","text":"<p>To include the API in a Maven project, add the following dependency to your <code>pom.xml</code> file:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.atomic.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;api&lt;/artifactId&gt;\n    &lt;version&gt;0.7.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"api/jvm/#gradle","title":"Gradle","text":"<p>For Gradle projects, add the following dependency to your <code>build.gradle.kts</code> file:</p> <pre><code>repositories {\n    mavenCentral()\n    maven {\n        url = uri(\"https://maven.pkg.github.com/HttpRafa/atomic-cloud\")\n        name = \"GitHub Packages\"\n        credentials {\n            username = project.findProperty(\"gpr.username\") as String?\n            password = project.findProperty(\"gpr.password\") as String?\n        }\n    }\n}\n\ndependencies {\n    implementation(\"io.atomic.cloud:api:0.7.0-SNAPSHOT\")\n}\n</code></pre> <p>If you're using Groovy-based Gradle (<code>build.gradle</code>), use:</p> <pre><code>dependencies {\n    implementation 'io.atomic.cloud:api:0.7.0-SNAPSHOT'\n}\n</code></pre>"},{"location":"api/jvm/channels/","title":"Channels","text":"<p>Channels are a pub/sub (publish/subscribe) messaging system within Atomic Cloud designed for efficient, secure, real\u2011time communication between servers. They work similarly to MQTT and are ideal for implementing features such as party systems, player notifications, and any functionality that requires inter\u2011server messaging.</p>"},{"location":"api/jvm/channels/#table-of-contents","title":"Table of Contents","text":"<ul> <li>What Are Channels?</li> <li>Prerequisites</li> <li>Receiving Messages</li> <li>Sending Messages</li> </ul>"},{"location":"api/jvm/channels/#what-are-channels","title":"What Are Channels?","text":"<p>Channels provide a central, consistent method for sending and receiving messages across distributed servers. By using channels, you ensure data integrity and security throughout your application, making it easier to orchestrate communication between various services or components.</p>"},{"location":"api/jvm/channels/#prerequisites","title":"Prerequisites","text":"<p>Before using channels, make sure to:</p> <ul> <li> <p>Choose a Unique Channel Name:   The channel name serves as the unique identifier for message routing.</p> </li> <li> <p>Subscribe to the Channel:   Only servers or clients that subscribe to a channel will receive its messages.</p> </li> <li> <p>Unsubscribe When Needed:   Subscribers can unsubscribe at any time to stop receiving messages.</p> </li> </ul>"},{"location":"api/jvm/channels/#receiving-messages","title":"Receiving Messages","text":"<p>To receive messages from a channel, subscribe and register a message handler using the JVM API.</p>"},{"location":"api/jvm/channels/#example","title":"Example","text":"<pre><code>var channel = Cloud.channels().subscribeToStrings(\"testChannel\");\nchannel.handler(message -&gt; {\n  // A message was received from the channel.\n});\nchannel.errorHandler(throwable -&gt; {\n  // Oh no! An error occurred while trying to receive a message from the channel.\n});\n</code></pre> <p>Once subscribed, every message sent to the channel will trigger the registered handler.</p>"},{"location":"api/jvm/channels/#sending-messages","title":"Sending Messages","text":"<p>Sending messages is simple. Use the API to send a message to a channel, and all subscribers will receive it.</p>"},{"location":"api/jvm/channels/#example_1","title":"Example","text":"<pre><code>Cloud.channels().publishString(\"testChannel\", \"MESSAGE\");\n</code></pre> <p>In this example, the string <code>\"MESSAGE\"</code> is broadcast to all clients subscribed to the \"testChannel\" channel.</p>"},{"location":"cli/","title":"What is the CLI?","text":"<p>The CLI is an essential part of Atomic Cloud. Similar to how <code>kubectl</code> functions for Kubernetes, the CLI allows you to manage the cloud without needing to provide everyone with SSH access to the server.</p>"},{"location":"cli/#installation","title":"Installation","text":"<p>This guide provides instructions on how to download, install, and use the CLI tool for managing the controller.</p>"},{"location":"cli/#step-1-download","title":"Step 1: Download","text":"<p>Download the latest CLI binary from the GitHub releases page.</p>"},{"location":"cli/#step-2-set-up-path","title":"Step 2: Set Up PATH","text":"<p>Place the downloaded binary in a directory that is included in your system's PATH. This ensures you can run the CLI from any terminal session.</p>"},{"location":"cli/#usage","title":"Usage","text":"<ul> <li>Launching the CLI:   Open your terminal and run the CLI command.</li> <li>Interactive Guidance:   Follow the on-screen instructions provided by the CLI to control the controller and manage your cloud network.</li> </ul> <p>Note: We\u2019re actively working to expand and enhance this documentation. Please check back soon for more detailed content and additional usage examples.</p>"},{"location":"controller/","title":"What is the Controller?","text":"<p>The Controller is a vital component of Atomic Cloud. It acts as the central management server by:</p> <ul> <li> <p>Overseeing Nodes:   It monitors and manages the nodes.</p> </li> <li> <p>Managing Servers:   It is responsible for initiating and supervising the servers launched by the cloud.</p> </li> </ul>"},{"location":"controller/#docker-installation-recommended","title":"Docker Installation (Recommended)","text":"<p>The most straightforward method to install the controller is by utilizing a Docker image. Follow the steps below to set it up using Docker Compose:</p>"},{"location":"controller/#step-1-create-the-docker-composeyml-file","title":"Step 1: Create the <code>docker-compose.yml</code> File","text":"<p>First, use a text editor to create the <code>docker-compose.yml</code> file:</p> <pre><code>nano docker-compose.yml\n</code></pre> <p>Next, add the following content to the file:</p> <pre><code>services:\n  controller:\n    image: ghcr.io/httprafa/atomic-cloud:latest\n    ports:\n      - \"8080:8080\"\n    environment:\n      - PTERODACTYL=true # Enable Pterodactyl plugin installation\n      - LOCAL=true       # Enable Local plugin installation\n    volumes:\n      - ./certs:/app/certs\n      - ./configs:/app/configs\n      - ./groups:/app/groups\n      - ./logs:/app/logs\n      - ./nodes:/app/nodes\n      - ./plugins:/app/plugins\n      - ./users:/app/users\n      - ./data:/app/data\n</code></pre>"},{"location":"controller/#step-2-start-the-container","title":"Step 2: Start the Container","text":"<p>To start the container, execute the following command:</p> <pre><code>docker compose up\n</code></pre>"},{"location":"controller/#manual-installation","title":"Manual Installation","text":"<p>Follow the steps below to manually install Atomic Cloud.</p>"},{"location":"controller/#step-1-download-the-cli-and-controller","title":"Step 1: Download the CLI and Controller","text":"<p>Download the latest release from our GitHub releases page.</p> <p>Controller: Choose the version that corresponds to the operating system where the Controller will run.</p> <p>CLI: Choose the version that matches the operating system on your local machine, from which you will manage the cloud.</p>"},{"location":"controller/#step-2-start-the-controller","title":"Step 2: Start the Controller","text":"<ol> <li>Open a terminal and navigate to the directory where the Controller is located.</li> <li>Start the Controller.</li> <li>Important: After startup, note the authentication token that is displayed. You will need this token later.    If you lose the token, you can retrieve it from our token retrieval guide.</li> </ol>"},{"location":"controller/#step-3-download-and-install-the-plugin","title":"Step 3: Download and Install the Plugin","text":"<ol> <li>Download the latest plugin version from our GitHub releases page.</li> <li>Place the plugin file into the <code>plugins</code> folder.</li> <li>Restart the Controller to load the new plugin.</li> </ol>"},{"location":"controller/#step-4-start-the-cli","title":"Step 4: Start the CLI","text":"<ol> <li>Open a terminal on your local device where you want to control the cloud.</li> <li>Start the CLI application.</li> <li>When prompted, select \"Add new controller\" and follow the on-screen instructions to complete the setup.</li> </ol>"},{"location":"controller/retrieve_token/","title":"Retrieve token","text":""},{"location":"controller/retrieve_token/#retrieve-the-admin-token-on-first-launch","title":"Retrieve the Admin Token on First Launch","text":"<p>When you run the controller for the first time, an admin token will be displayed in the console. You will need this token to connect via the CLI. For more information, please refer to the How to use the CLI guide.</p> <p></p>"},{"location":"controller/retrieve_token/#retrieve-the-admin-token-after-the-first-launch","title":"Retrieve the Admin Token After the First Launch","text":"<p>If you lose the token after the initial launch, you can retrieve it from the default admin user's file. The file is located in the <code>users</code> directory within your controller's installation folder.</p>"},{"location":"plugins/","title":"Introduction","text":"<p>The Controller is built with extensibility at its core, supporting a wide array of plugin platforms. At present, the primary platform for developing plugins is WebAssembly (WASM), leveraging the WASI Preview 2 specification. This modern approach delivers a flexible and high-performance environment for plugin development.</p> <p>If you prefer not to use a WASM plugin or have alternative ideas, you are welcome to implement your own plugin mechanism. We encourage commservery contributions\u2014feel free to submit a pull request with your enhancements or alternative implementations.</p>"},{"location":"plugins/wasm/","title":"Available Options","text":"<p>Currently, Atomic Cloud offers only one option: a local version (similar to CloudNet). Additionally, there is a plugin designed to integrate with Pelican, but it is still being ported to the rewritten controller.</p> <p>If you have a unique integration requirement, you are welcome to create your own WASM plugin. Simply develop the plugin and place it in the Plugins directory on a WASM-enabled Controller.</p>"},{"location":"plugins/wasm/permissions/","title":"Permissions","text":"<p>WASM plugins operate within a sandbox environment, meaning they have very limited access to the host system by default. Both the WASI standard and the Controller provide APIs to facilitate integration with network or local resources. However, you must explicitly grant the necessary permissions to each plugin to enable such access.</p> <p>You can configure these permissions in the <code>configs/wasm-plugins.toml</code> file. For example:</p> <ol> <li>Open the Configuration File:</li> </ol> <pre><code>nano wasm-plugins.toml\n</code></pre> <ol> <li>Configure Plugin Permissions:</li> </ol> <pre><code># This configuration is crucial for granting the plugins their required permissions\n# https://httprafa.github.io/atomic-cloud/usage/plugins/wasm/permissions/\n\n[[plugins]]\nname = \"local\"\ninherit_stdio = false\ninherit_args = false\ninherit_env = false\ninherit_network = false\nallow_ip_name_lookup = false\nallow_http = false\nallow_process = true\nallow_remove_dir_all = true\nmounts = []\n\n[[plugins]]\nname = \"pelican\"\ninherit_stdio = false\ninherit_args = false\ninherit_env = false\ninherit_network = true\nallow_ip_name_lookup = true\nallow_http = true\nallow_process = false\nallow_remove_dir_all = false\nmounts = []\n</code></pre>"},{"location":"plugins/wasm/permissions/#explanation-of-configuration-options","title":"Explanation of Configuration Options","text":"<ul> <li> <p>inherit_stdio, inherit_args, inherit_env:   These options control whether the plugin inherits the standard I/O streams, command-line arguments, and environment variables from the host.</p> </li> <li> <p>inherit_network:   Determines if the plugin can access the network interfaces of the host.</p> </li> <li> <p>allow_ip_name_lookup:   Enables the plugin to perform DNS lookups.</p> </li> <li> <p>allow_http:   Permits the plugin to make HTTP requests.</p> </li> <li> <p>allow_child_processes:   Specifies whether the plugin can spawn child processes.</p> </li> <li> <p>mounts:   Configures file or socket mounts between the host and the plugin environment. For instance, mounting the Docker socket allows a plugin to interact with Docker on the host.</p> </li> </ul> <p>This setup ensures that plugins run securely while still having the flexibility to integrate with local or network resources as required.</p>"},{"location":"plugins/wasm/local/","title":"Installation","text":"<ol> <li>Download the <code>local-plugin.wasm</code> file from the GitHub releases page.</li> <li>Place the downloaded file into the <code>plugins</code> directory.</li> <li>Start the controller.</li> </ol>"},{"location":"plugins/wasm/local/template/","title":"What is a template?","text":"<p>A template in the CloudNet world is a predefined state of a server. When a new server is started, this template is copied to the new server's directory. This allows for the creation of specific templates for different types of servers, such as a lobby server or a game server. For example, you can have a template for a Minecraft lobby server and another for a Bedwars game server.</p>"},{"location":"plugins/wasm/local/template/#example-file-for-papermc","title":"Example File (for PaperMC)","text":"<pre><code>description = \"PaperMC improves Minecraft's ecosystem with fast, secure software and an expanding plugin API, providing quick releases and helpful support as the most widely used, performant, and stable software available.\"\nversion = \"0.1.0\"\nauthors = [\"HttpRafa\"]\n\nexclusions = [\"template.toml\", \"prepare/\"]\n\nshutdown = \"stop\"\n\n[environment]\nPROJECT = \"paper\"\nVERSION = \"latest\"\nBUILD_NUMBER = \"latest\"\nSERVER_JARFILE = \"server.jar\"\n\n[prepare.unix]\ncommand = \"bash\"\nargs = [\"-c\", \"chmod +x prepare/unix.sh &amp;&amp; ./prepare/unix.sh\"]\n\n[prepare.windows]\ncommand = \"powershell.exe\"\nargs = [\"-NoProfile\", \"-ExecutionPolicy\", \"Bypass\", \"-File\", \"prepare/windows.ps1\"]\n\n[startup.unix]\ncommand = \"bash\"\nargs = [\"-c\", \"chmod +x startup/unix.sh &amp;&amp; ./startup/unix.sh\"]\n\n[startup.windows]\ncommand = \"powershell.exe\"\nargs = [\"-NoProfile\", \"-ExecutionPolicy\", \"Bypass\", \"-File\", \"startup/windows.ps1\"]\n</code></pre>"},{"location":"plugins/wasm/pelican/","title":"Installation","text":"<p>Note: This plugin is currently being ported to a rewritten controller. Therefore, it is only available for versions below v0.6.0-alpha of the controller and only supports Pterodactyl, not Pelican. The rewrite will support Pelican, so please keep that in mind.</p> <ol> <li>Download the <code>pelican-plugin.wasm</code> file from the GitHub releases page.</li> <li>Place the downloaded file into the <code>plugins</code> directory.</li> <li>Start the controller.</li> </ol>"},{"location":"wrapper/","title":"Wrapper","text":"<p>The Wrapper is an intermediary process that bridges the Controller and a target game server. It is especially useful when direct modifications to the game server\u2019s code are not feasible. For example, in environments where a Vanilla Minecraft server cannot be altered to support custom behaviors, the Wrapper allows the server to communicate with the controlling system by simulating required functions.</p>"},{"location":"wrapper/#purpose","title":"Purpose","text":"<p>The primary purpose of the Wrapper is to ensure that the game server meets specific operational requirements imposed by the Controller. A common requirement is the need to send regular heartbeat messages. For instance, the Controller expects a heartbeat at 15-second intervals. If the server does not send a heartbeat within that window, it is deemed \"dead\" or \"stopped.\" Since some game servers cannot be modified to provide this functionality natively, the Wrapper monitors the server process and simulates the heartbeat functionality on its behalf.</p>"},{"location":"wrapper/#functionality","title":"Functionality","text":"<ul> <li> <p>Process Monitoring:   The Wrapper launches and continuously monitors the game server (its child process). During runtime, it intercepts the server\u2019s standard input and output streams to manage communication.</p> </li> <li> <p>Heartbeat Simulation:   Rather than requiring the server to send its own heartbeat, the Wrapper periodically sends a simulated heartbeat message at the defined interval. If the Controller does not receive a heartbeat within the expected timeframe, it marks the server as unresponsive.</p> </li> </ul>"},{"location":"wrapper/#caveats","title":"Caveats","text":"<ul> <li> <p>Limited Functionality:   Currently, the Wrapper supports basic functions such as sending user transfer commands via the server\u2019s standard input. Certain advanced functionalities (e.g., server transfers) may be limited or altered. For example, while the Wrapper can forward user transfer commands to the server, it cannot modify more complex behaviors inherent to the server software.</p> </li> <li> <p>Maintenance Status:   The Wrapper is in a somewhat unmaintained state at present. Although it works well for basic scenarios, improvements are planned to enhance its capabilities and broaden compatibility with a wider range of game server environments.</p> </li> </ul>"}]}